/**
  ******************************************************************************
  * @file    main.c
  * @author  MCU Application Team
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) Puya Semiconductor Co.
  * All rights reserved.</center></h2>
  *
  * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */

#include "main.h"

static void APP_SystemClockConfig(void);
static void APP_GPIOConfig(void);

#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))

struct task_s { 

	uint32_t lastTick;
	uint32_t periodTick;
	void (*func)(void);
};


/*

		SR1

		PA11 - ROW_DATA_IN  Data    14
		PA10 - ROW_SCLK_IN  Clock   11
		PA9  - ROW_RCLK_IN  Latch   12

		SR2

		PB4  - COL_DATA_IN	Data
		PB6  - COL_SCLK_IN	Clock
		PB5  - COL_RCLK_IN	Latch

*/

#define ID_ROW 1
#define ID_COL 2

#define MAX_ROW   32
#define MAX_COL   32
#define MAX_DEPTH 4

static uint8_t screen[MAX_DEPTH][MAX_ROW][MAX_COL/8]; 
    
static void outputBitmapX(uint8_t *ptr) {

	LL_GPIO_TogglePin(GPIOA, LL_GPIO_PIN_8);					// GPIO5

	for (int row=0; row<MAX_ROW; row++) {
		
		LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_9); 					// ROW LATCH

		if (row == 0) {
			LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_11);					// ROW DATA
    } else {
			LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_11);				// ROW DATA
    }

		LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_10);						// ROW CLOCK
		LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_10);					// ROW CLOCK
				
		LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_5);						// COL LATCH


		ptr += (MAX_COL/8)-1;
				
		for (int k=0; k<(MAX_COL/8); k++) {

			uint8_t value = *ptr--;
	
			for(int i=0; i<8; i++) {
				
					if (value & 0x1) {
							LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_4);		// COL DATA
					} else {
							LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_4);	// COL DATA
					}

					LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_6);				// COL CLOCK																					
					LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_6);			// COL CLOCK

					value = value >> 1;
			}
		}
				
		ptr++;		
		ptr += (MAX_COL/8);
				
		LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_5);							// COL LATCHs
				
		LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_9);							// ROW LATCH
	}
	
	LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_9);							// ROW LATCH
	LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_11);						// ROW DATA

	LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_10);							// ROW CLOCK
	LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_10);						// ROW CLOCK


	LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_5);							// COL LATCH

	for (int k=0; k<4; k++) {

		uint8_t value = 0;

		for(int i=0; i<8; i++) {
			
				if (value & 0x1) {
						LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_4);			// COL DATA
				} else {
						LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_4);		// COL DATA
				}

				LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_6);					// COL CLOCK																																
				LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_6);				// COL CLOCK

				value = value >> 1;
		}
	}
		
	LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_5);								// COL LATCH

	LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_9);								// ROW LATCH
}




static void outputBitmap(void) {

	static int i = 0;

	outputBitmapX((uint8_t *)&screen[i]);
	
	i++;
	if (i == MAX_DEPTH) {
		i = 0;
	}
}




static void updateBitmap(void) {

    static int col = 0;
    static int row = 0;
    static int lcol = 0;
    static int lrow = 0;
		static int xxx = 3;
		static int lxxx = 3;

    screen[0][lrow][lxxx] &= ~(1 << lcol);    
    screen[0][row][xxx] |= 1 << col;

    lcol = col;
    lrow = row;
		lxxx = xxx;
    
    
    col++;
    if (col >= 8) {
				xxx--;			
        col = 0;
				if (xxx < 0) {
					xxx = 3;
					row++;
					if (row >= 8) {
							row = 0;            
					}
				}
    }    
}


volatile static uint32_t systickCnt;

void SysTick_Handler(void) {
  systickCnt++;
}

const uint8_t nfont[128][8] = {
	
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 10
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 20
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 30
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },

	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 40
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x70, 0x88, 0x98, 0xA8, 0xC8, 0x88, 0x70, 0x00 }, // 48 - '0'
	{ 0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00 },

	{ 0x70, 0x88, 0x08, 0x10, 0x20, 0x40, 0xF8, 0x00 }, // 50
	{ 0xF0, 0x08, 0x08, 0x70, 0x08, 0x08, 0xF0, 0x00 },
	{ 0x88, 0x88, 0x88, 0xF8, 0x08, 0x08, 0x08, 0x00 },
	{ 0xF8, 0x80, 0x80, 0xF0, 0x08, 0x08, 0xF0, 0x00 },
	{ 0x70, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x70, 0x00 },
	{ 0xF8, 0x08, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00 },
	{ 0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00 }, 
	{ 0x70, 0x88, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00 }, // 57 - '9'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	
	{ 0x70, 0x88, 0x08, 0x10, 0x20, 0x40, 0xF8, 0x00 }, // 60
	{ 0xF0, 0x08, 0x08, 0x70, 0x08, 0x08, 0xF0, 0x00 },
	{ 0x88, 0x88, 0x88, 0xF8, 0x08, 0x08, 0x08, 0x00 },
	{ 0xF8, 0x80, 0x80, 0xF0, 0x08, 0x08, 0xF0, 0x00 },
	{ 0x70, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x70, 0x00 },
	{ 0x70, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00 }, // 65 - 'A'
	{ 0xF0, 0x88, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00 },
	{ 0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70, 0x00 },
	{ 0xF0, 0x88, 0x88, 0x88, 0x88, 0x88, 0xF0, 0x00 },
	{ 0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0xF8, 0x00 },
	
	{ 0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80, 0x00 }, // 70
	{ 0x70, 0x88, 0x80, 0x98, 0x88, 0x88, 0x70, 0x00 },
	{ 0x88, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00 },
	{ 0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xF8, 0x00 },
	{ 0xF8, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00 },
	{ 0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88, 0x00 },
	{ 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF8, 0x00 },
	{ 0xD8, 0xA8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00 },
	{ 0x88, 0xC8, 0xA8, 0xA8, 0xA8, 0x98, 0x88, 0x00 },
	{ 0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00 },

	{ 0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x80, 0x00 }, // 80
	{ 0x70, 0x88, 0x88, 0x88, 0xA8, 0x98, 0x78, 0x00 },
	{ 0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x90, 0x88, 0x00 },
	{ 0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00 },
	{ 0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00 },
	{ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00 },
	{ 0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00 },
	{ 0x88, 0x88, 0x88, 0xA8, 0xA8, 0x50, 0x50, 0x00 },
	{ 0x88, 0x50, 0x50, 0x20, 0x50, 0x50, 0x88, 0x00 },
	{ 0x88, 0x88, 0x50, 0x20, 0x20, 0x20, 0x20, 0x00 },

	{ 0xF8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00 }, // 90 - 'Z'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x78, 0x88, 0x88, 0x78, 0x00 }, // 97 - 'a'
	{ 0x80, 0x80, 0x80, 0xF0, 0x88, 0x88, 0xF0, 0x00 },
	{ 0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00 },
	
	{ 0x08, 0x08, 0x08, 0x78, 0x88, 0x88, 0x78, 0x00 }, // 100
	{ 0x00, 0x00, 0x70, 0x88, 0xF8, 0x80, 0x70, 0x00 },
	{ 0x30, 0x48, 0x40, 0xE0, 0x40, 0x40, 0x40, 0x00 },
	{ 0x70, 0x88, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00 },
	{ 0x80, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x00 },
	{ 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00 },
	{ 0x10, 0x00, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00 },
	{ 0x80, 0x80, 0x88, 0x90, 0xA0, 0xD0, 0x88, 0x00 },
	{ 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x00 },
	{ 0x00, 0x00, 0x00, 0xD0, 0xA8, 0xA8, 0xA8, 0x00 },
	
	{ 0x00, 0x00, 0x00, 0xF0, 0x88, 0x88, 0x88, 0x00 }, // 110
	{ 0x00, 0x00, 0x00, 0x70, 0x88, 0x88, 0x70, 0x00 },
	{ 0x00, 0x70, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x00 },
	{ 0x70, 0x90, 0x90, 0x70, 0x10, 0x18, 0x10, 0x00 },
	{ 0x00, 0x00, 0x00, 0xB8, 0xC0, 0x80, 0x80, 0x00 },
	{ 0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xF0, 0x00 },
	{ 0x00, 0x00, 0x20, 0x70, 0x20, 0x20, 0x20, 0x00 },
	{ 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x78, 0x00 },
	{ 0x00, 0x00, 0x00, 0x88, 0x50, 0x50, 0x20, 0x00 },
	{ 0x00, 0x00, 0x00, 0x88, 0xA8, 0xA8, 0x50, 0x00 },

	{ 0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00 }, // 120
	{ 0x00, 0x00, 0x88, 0x88, 0x78, 0x08, 0xF0, 0x00 },
	{ 0x00, 0x00, 0xF8, 0x10, 0x20, 0x40, 0xF8, 0x00 }, // 122 - 'z'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	
	
};


static void drawBlankCharX(int row, int col, uint8_t *ptr) {

	int coff = col % 8;
	ptr += (row * MAX_COL/8) + (col/8);
	
	for (int i=0; i<8; i++) {
		
		*ptr &= ~(252 >> coff);		
		if (coff) {
			*(ptr+1) &= ~(252 << (8-coff));		
		}
		
		ptr += MAX_COL/8;
	}
}

static void drawBlankChar(int row, int col, int depth) {
	
	drawBlankCharX(row, col, (uint8_t *)&screen[depth]);
}




static void drawCharX(int row, int col, uint8_t *ptr, int c) {
	
	if (col < 0) {
		
		if (col >= -5) {
			
			int coff = col * -1;
			ptr += (row * MAX_COL/8);

			for (int i=0; i<8; i++) {
			
				*ptr &= ~(252 << coff);
				*ptr |= nfont[c][i] << coff;
				ptr += MAX_COL/8;
			}			
		}
		
		// TODO - testme
		
	} else if ((col >= MAX_COL-5) && ( col < MAX_COL)) {

		int coff = col % 8;
		ptr += (row * MAX_COL/8) + (col/8);
			
		for (int i=0; i<8; i++) {
			
			*ptr &= ~(252 >> coff);		
			*ptr |= nfont[c][i] >> coff;
			
			ptr += MAX_COL/8;
		}
		
		// TODO - testme
		
	} else if ( col < MAX_COL) {

		int coff = col % 8;
		ptr += (row * MAX_COL/8) + (col/8);
			
		for (int i=0; i<8; i++) {
			
			*ptr &= ~(252 >> coff);		
			*ptr |= nfont[c][i] >> coff;
			if (coff) {
				*(ptr+1) &= ~(252 << (8-coff));		
				*(ptr+1) |= nfont[c][i] << (8-coff);
			}
			
			ptr += MAX_COL/8;
		}
	}
}

static void drawCharY(int row, int col, int depth, int c) {

	drawCharX(row, col, (uint8_t *)&screen[depth], c);
}

static void drawChar(int row, int col, int intensity, int c) {

	if (intensity > MAX_DEPTH-1) {
		intensity = MAX_DEPTH-1;
	}		
	
	for (int i=0; i<=intensity; i++) {
		drawCharY(row, col, i, c);
	}
}

static void drawString(int row, int col, int intensity, char *ptr) {
	
		while (*ptr) {			
			drawChar(row, col, intensity, *ptr);
			col += 6;
			ptr++;
		}	
}



static void updateBitmap2(void) {

	static int i = 0;

	drawChar(0, 0, 0, '0'+i);
	
	i++;
	if (i > 9) {
		i = 0;
	}
}


int random(unsigned long count);

//1+MWC%10; would provide the proverbial "take a number from 1 to 10", (but with not quite, but virtually, equal probabilities)


static void setPixelY(int row, int col, int depth) {
	
	uint8_t *ptr = (uint8_t *)&screen[depth];

	int coff = col % 8;
	ptr += (row * MAX_COL/8) + (col/8);

	*ptr &= ~(0x80 >> coff) ;
	*ptr |= (0x80 >> coff);
}


static void setPixel(int row, int col, int intensity) {

	for (int i=0; i<=intensity; i++) {
		setPixelY(row, col, i);
	}
}


static void resetPixel(int row, int col) {
	
	for (int i=0; i<MAX_DEPTH; i++) {
		
		uint8_t *ptr = (uint8_t *)&screen[i];

		int coff = col % 8;
		ptr += (row * MAX_COL/8) + (col/8);
	
		*ptr &= ~(0x80 >> coff) ;		
	}
}


static void updateBitmap3(void) {

		for (int i=0; i<10; i++) {

				int row = random(10);
				int col = random(32);
		
				resetPixel(row, col);						
		}


		for (int i=0; i<10; i++) {

				int row = random(11);
				int col = random(32);
		
				resetPixel(21+row, col);						
		}

}

static void updateBitmap4(void) {

		for (int i=0; i<10; i++) {

				int row = random(10);
				int col = random(32);
				int intensity = random(4);
		
				setPixel(row, col, intensity);						
		}


		for (int i=0; i<10; i++) {

				int row = random(11);
				int col = random(32);
				int intensity = random(4);
		
				setPixel(21+row, col, intensity);						
		}
}



static void updateBitmap5(void) {

	static int i = MAX_COL;
	
	                    //012345678901234567890
	drawString(12, i, 3, "MERRY CHRISTMAS");
	i--;
	if (i < (-15*6)) {
		i = MAX_COL;
	}
}





int main(void)
{
    struct task_s tasks[] = {

		{ 0, 0,  outputBitmap },  /* update a different row every 10ms */
//		{ 0, 50, updateBitmap2 },  /* 1S animations written to bitmap */
		{ 0, 1000, updateBitmap3 },  /* 1S animations written to bitmap */
		{ 0, 1000, updateBitmap4 },  /* 1S animations written to bitmap */
		{ 0, 50, updateBitmap5 },  /* 0.5S animations written to bitmap */
//		{ 0, 10,  updateBitmap },  /* 50ms animations written to bitmap */
	};
	
	
	
  APP_SystemClockConfig();
  APP_GPIOConfig();

	LL_SYSTICK_EnableIT();

  while (1)
  {
#if 0		
    LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_5);
    LL_mDelay(1000);
#else		
		struct task_s *task = tasks;
	
		for (unsigned int i=0; i<NELEMS(tasks); i++) {
		 		 
			if ((task->periodTick == 0) ||
				  ((uint32_t)(systickCnt - task->lastTick) >= task->periodTick)) {
                
				(*task->func)();
				task->lastTick = systickCnt;
			}
			
			task++;
		}
#endif		
  }
}

//#define OLDCODE

#ifndef OLDCODE
static void APP_SystemClockConfig(void)
{
  LL_UTILS_ClkInitTypeDef ClkInit = { LL_RCC_SYSCLK_DIV_1, LL_RCC_APB1_DIV_1 };

  LL_RCC_HSI_Enable();
  LL_RCC_HSI_SetCalibFreq(LL_RCC_HSICALIBRATION_24MHz);
  while (LL_RCC_HSI_IsReady() != 1);
  LL_PLL_ConfigSystemClock_HSI(&ClkInit);
  SysTick_Config(48000);
  NVIC_SetPriority(SysTick_IRQn, 0);
}
#else
static void APP_SystemClockConfig(void)
{
  LL_UTILS_ClkInitTypeDef UTILS_ClkInitStruct;
  //Enable internal high speed
  LL_RCC_HSI_Enable();
  //Set to 24MHz, the frequency can be fine-tuned here, and the higher the value, the faster the frequency
  LL_RCC_HSI_SetCalibFreq(LL_RCC_HSICALIBRATION_24MHz);
  //Wait for stabilization
  while (LL_RCC_HSI_IsReady() != 1);
  //AHB does not divide the frequency
  UTILS_ClkInitStruct.AHBCLKDivider = LL_RCC_SYSCLK_DIV_1;
  //APB is not crossover
  UTILS_ClkInitStruct.APB1CLKDivider = LL_RCC_APB1_DIV_1;
  //Set the system clock source to PLL+HSI, note the method name 
  LL_PLL_ConfigSystemClock_HSI(&UTILS_ClkInitStruct);
  //Update the settings for SysTick
  LL_InitTick(48000000U, 1000U);
}
#endif

static void APP_GPIOConfig(void)
{
  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
  LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_9, LL_GPIO_MODE_OUTPUT);
  LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_10, LL_GPIO_MODE_OUTPUT);
  LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_11, LL_GPIO_MODE_OUTPUT);


  LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_8, LL_GPIO_MODE_OUTPUT);	// GPIO5


	
  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
  LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_4, LL_GPIO_MODE_OUTPUT);
  LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT);
  LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_6, LL_GPIO_MODE_OUTPUT);	
}

void APP_ErrorHandler(void)
{
  while (1);
}

#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line)
{
  while (1);
}
#endif /* USE_FULL_ASSERT */
